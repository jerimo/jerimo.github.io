---
layout: posts
title: "[백준] 1966 프린터 큐 (C++)"
categories:
  - BOJ
last_modified_at: 2021-02-26
author_profile: true
tags:
  - 구현
  - Algorithm
toc: true
toc_sticky: true
sidebar:
  title: Posts
  nav: "sidebar-contents"
---

# 1966 | 프린터 큐


### 🙋‍♀️ 문제

-----

여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.

1. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
2. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.

예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.

여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.

### 🙌 입출력

-----

첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.

테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.

각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.

### 🙋‍♂️ 예제 입출력

-----

```
3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1
```

```
1
2
5
```


### 🚀 코드

-----

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	ios::ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int t = 0;
	int n, m = 0;
	int pri = 0;

	cin >> t;
	for (int i = 0; i < t; i++) {
		cin >> n >> m;
		priority_queue<pair<int, int>> PQ; // { 중요도, 문서 번호 }
		queue<pair<int, int>> que;
		for (int j = 0; j < n; j++) {
			cin >> pri;
			PQ.push({ pri,j });
			que.push({ pri,j });
		}

		int cnt = 1;
		while (!PQ.empty()) {
			int maxPriority = PQ.top().first;
			if (que.front().first < maxPriority) {
				// 현재 문서보다 중요도가 높은 문서가 있으면 그 문서를 맨 뒤로 보냄
				int x = que.front().first;
				int idx = que.front().second;
				que.pop();
				que.push({ x,idx });
			}
			else {
				// 가장 높은 중요도를 기준으로 정렬이 끝났으면
				// 그 숫자를 pop하기 전에 m인지 확인하고 다르면 cnt를 증가시킨 후 pop
				// 이후 다음으로 높은 중요도를 기준으로 다시 정렬
				PQ.pop();
				if (que.front().second == m) {
					cout << cnt << "\n";
					break;
				}
				else {
					cnt++;
					que.pop();
				}
			}
		}
	}
	return 0;
}
```

### 🌠 메모

-----

처음 러프하게 짤때는 아주 쉽게 코드를 짰는데 문제의 조건이 까다로워 단순히 우선순위 큐를 사용해서는 답이 맞지가 않았다.

#### 내가 풀이한 방법은
- 우선순위 큐(```PQ```)를 통해 현재 큐에 있는 문서들 중 가장 높은 우선순위(```maxPriority```)를 확인한다.
- 위의 ```maxPriority```를 사용해, 문서 중 중요도가 높은 문서가 하나라도 있다면 그 문서를 ```que``` 가장 뒤에 재배치한다.
- 그게 아니라면, que 가장 앞에 위치한 문서가 가장 높은 중요도를 가지고 있으므로, 이 문서가 확인하고자 하는 문서(```m```)인지 확인하고 출력(```pop()```)
- ```PQ```에서도 마찬가지로 ```pop()```했으므로, 이제 다음으로 높은 중요도를 가지고 위를 반복한다.
- 문서를 출력할 때 마다 ```cnt```를 증가시키므로 해당 문서를 찾았으면 cnt를 바로 출력한 뒤 반복문을 탈출한다.
- 각각의 중요도에 따라 문서룰 계속해서 재배치 하므로, while문의 조건은 ```PQ가 비어있지 않을 때```이다.


#### 단계별 확인

```
4 2
1 2 3 4
```
위의 경우를 봐보자.

처음 ```maxPriority = 4```이므로, 중요도 4인 문서가 출력되기 전까지는 낮은 중요도의 문서들이 순서대로 ```pop, push```되어, ```[4 1 2 3]```이 되어있을 것이다.

4를 출력한 다음에는 남은 문서 ```[1 2 3]```이 다시 높은 중요도인 3을 기준으로 재배치 되어야 하므로 위를 반복해 ```[3 1 2]```로 만든다.

이런식으로 중요도가 높은 문서대로 출력을 한 뒤에는 다시 정렬을 해줘야 한다.
