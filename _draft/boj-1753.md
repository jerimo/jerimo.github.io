---
layout: posts
title: "[백준] 1916 최소비용 구하기"
categories:
  - BOJ
last_modified_at: 2021-02-24
author_profile: true
tags:
  - 최단 경로
  - Algorithm
toc: true
toc_sticky: true
sidebar:
  title: Posts
  nav: "sidebar-contents"
---

# 1149 | 최소비용 구하916


### 🙋‍♀️ 문제

-----



### 🙌 입출력

-----



### 🙋‍♂️ 예제 입출력

-----

```

```

```

```


### 🚀 코드

-----

```c++
#include <iostream>
#include <cstdlib>
#include <vector>
#include <list>
#include <queue>
using namespace std;

int n = 0;
int m = 0;

vector<pair<int, int>> graph[20001];

void dijkstra(int start) {
	priority_queue<pair<int, int>> que;
	vector<int> dist(n + 1, 987654321);

	dist[start] = 0;
	que.push({ 0,start });

	while (!que.empty()) {
		int idx = que.top().second; // 가장 경로가 짧은 정점의 도착지
		int cost = -que.top().first; // 가장 짧은 경로의 경로값
		que.pop();

		if (dist[idx] < cost) {
			// 큐에 저장된 값보다 dist의 값이 더 작으면 패스
			continue;
		}
		for (int i = 0; i < graph[idx].size(); i++) {
			int next = graph[idx][i].second;
			// nextCost는 확인한 경로값에 cost를 더한 값
			int nextCost = graph[idx][i].first + cost;

			if (dist[next] > nextCost) {
				dist[next] = nextCost;
				que.push({ -nextCost,next });
			}
		}
	}

	for (int i = 1; i <= n; i++) {
		if (dist[i] == 987654321) {
			printf("INF\n");
		}
		else printf("%d\n", dist[i]);
	}
	return;
}

int main() {
	int u, v, w = 0;
	scanf("%d %d", &n, &m);
	int start = 0;
	scanf("%d", &start);
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &u, &v, &w);
		graph[u].push_back({ w,v });
	}

	dijkstra(start);


	return 0;
}
```

### 🌠 메모

-----

다익스트라 방법으로 문제 풀었음
이거 단계별로 그림 추가할 예정

inf초기화는 987654321로 하면 됨
